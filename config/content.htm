<h1>About</h1>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>
<h1>weeks</h1>
<h2>Week2~Week5</h2>
<p>week2</p>
<p>建立個人倉儲cad2019及編輯</p>
<p>1.下載<a href="https://drive.google.com/file/d/1fxMdqdCoCL__O1IpZ-Sv-A_4-c77Wx4E/view?usp=sharing">2019Fall可攜套件.7z</a><span> (編譯  Solvespace 用)，完成後並開啟<br/>2.登入自己的github帳號後，創建新的倉儲cad2019。<br/></span><span>3.進入要存放資料夾tmp。<br/></span><span>4.輸入</span><span>git clone  <span>https://github.com/s40723239/cad2019複製<span>個人倉儲至資料夾</span><span>。</span></span><span><br/>5.輸入git submodule add https://github.com/mdecourse/cmsimde.git 取得子模組資料。<br/>6.進入cmsimde，輸入python -m pip install flask_cors 更改模組。<br/>7.完成後，python wsgi.py 開始編輯倉儲(login密碼為admin)。<br/>8.編輯完成後，git status<span><span> </span>&gt;</span><span> </span>git add .<span><span> </span>&gt;</span><span> </span>git commit -m "...."<span><span> </span>&gt;</span><span> </span>git push。</span></span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/U8CUILw_H_Q" width="560"></iframe></p>
<p><span><span>week3</span></span></p>
<p><strong>進行Solvespace 編譯</strong></p>
<p>1.<span>將 Y:\portablegit\bin\sh.exe 改名為 sh_rename_for_solvespace.exe</span></p>
<p>2.<span>查驗 git 版本是否在"2.13以上"</span></p>
<p><span>3.git clone --recurse-submodules https://github.com/solvespace/solvespace.git solvespace(務必在網路穩定地方下進行下載)</span></p>
<p><span>4.編輯Y:\tmp\solvespace\extlib\angle\CMakeLists.txt 開啟後將第713行及714行前方加上"#"</span></p>
<p><span>5.將 libpng.dll.a 的編譯，改名為 libpng_static.a, 並放到編譯系統的 lib 目錄中</span></p>
<p><span>6. cd solvespace &gt;cd extlib &gt;cd libpng &gt;mkdir build &gt; cd build </span></p>
<p><span>7.輸入cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release</span></p>
<p><span>8.輸入mingw32-make &gt; 退到solvespace &gt; mkdir build &gt; cd build</span></p>
<p><span>9.在執行一次cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release</span></p>
<p><span>10.在輸入mingw32-make &gt; Done</span></p>
<p><span><span>        <iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/qaVN7s19UUg" width="560"></iframe></span></span></p>
<p><span>week5</span></p>
<p><span>使用solvespace 練習繪製圖案</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/hlipc0IuE-A" width="560"></iframe></span></p>
<p><br/><br/><br/></p>
<h2>Week6~Week9</h2>
<p>week6</p>
<p><span>利用Solvespace畫出車子</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/vvHHd2R90cM" width="560"></iframe></p>
<p><span>V-rep 模型控制</span></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/eXCRexQXSlg" width="560"></iframe></p>
<p><span></span>week7</p>
<p>更改<span>solvespace中about的內容</span><strong></strong></p>
<p><strong><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/-LvNGgdgEOg" width="560"></iframe></strong></p>
<p><span><img alt="" height="551" src="/images/solvespace_fZbOQyU8f6.png" width="1074"/></span></p>
<p><span>solvespace零件圖</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/2vAPgU7QPSI" width="560"></iframe></span></p>
<p>week8 </p>
<p>啟用cmsimde裡的網誌系統</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/7SJMhKjCvbg" width="560"></iframe></p>
<p><span>導入webots</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/PXkapeYze0Y" width="560"></iframe></span></p>
<p><span></span></p>
<h2>Week10~Week14</h2>
<p>week10</p>
<p><span>1.由組長創建</span><span>分組網站 </span></p>
<p>2.由組員透過fork加入創建之分組網站</p>
<p>3.加入後用git  clone submodules 組別倉儲網址 </p>
<p>4.以git pull request的方式進行推送(必須由組長認證推送內容才可以成功推送)</p>
<p>5.閱讀nx12及nx3的操作手冊和教程</p>
<p>week12</p>
<p>將組長分配的翻譯作業做完</p>
<p>我被分配到NX 12 for Engineering Design 的第八章</p>
<p><span style="color: #ff0000;">第八章 有限元分析</span></p>
<p>有限元分析（FEA）是有限元法（FEM）的預測結構或流體的響應特性所施加的因素，例如力，壓力，熱，和振動的實際應用。</p>
<p>可以幫助工程師們有一個更好的了解產品的性能在製造和測試之前。</p>
<p><span style="color: #ff0000;">8.1概述</span></p>
<p><span style="color: #ff0000;">8.1.1元件形狀和節點</span><br/> 的元素可以被分類為基於維度數目和節點中的元素的數量不同的類型。以下是一些類型的用於離散元件組成。</p>
<p><span style="color: #ff0000;">8.1.2 Solution Steps</span></p>
<p>啟動模擬&gt;選擇材料特性&gt;運用負載&gt;運用邊界條件&gt;嚙合機構&gt;解決方案和結果</p>
<p><span style="color: #ff0000;">8.1.3 Simulation Navigator</span></p>
<p><span>仿真Navigator提供的能力，激活現有的解決方案，創建新的，並通過創建和修改運動的物體使用創建的解決方案來構建機制。要顯示模擬導航</span><br/><span>➢在資源欄中單擊仿真Navigator選項卡如該圖所示</span><br/><span>它顯示了模型創建仿真的列表。在每個模擬中，它顯示載荷，邊界條件，多種網孔的列表，結果，產生的等報告。</span></p>
<p><span style="color: #ff0000;">8.2模擬CREATION</span></p>
<p>➢將文件複製並粘貼Impeller_impeller.prt到一個新的文件夾，以避免被改變向大會提出，如果該部分尚未在NX窗口中打開➢點擊新建→模擬<br/> ➢打開此新複製的文件</p>
<p>如果部分在NX已經打開，然後從頂部功能區欄，點擊應用程序→設計<br/> 或者➢點擊文件→所有應用程序→模擬→設計仿真<br/> 當你第一次打開設計仿真模塊的任何文件，它會自動彈出新的有限元與仿真對話框創建一個模擬。在彈出的對話框中，單擊確定以創建新的模擬。<br/> 那麼在接下來的彈出窗口的解決方案，您可以選擇解算器和分析類型。<br/> 默認的求解器類型的NX Nastran設計和分析類型結構。<br/> ➢選擇確定以創建一個新的解決方案稱為方案一，將被顯示在模擬導航。在這裡，我們保持其他項目為默認值。</p>
<p>現在，模擬導航將類似於下圖</p>
<p><span style="color: #ff0000;">8.3材料性能</span><br/> 下一個步驟是將材料特性分配給該模擬的實體模型。因為我們沒有在庫中的任何數據檢索標準的材料，我們將創建一個。讓我們假設，我們將用鋼管來製造葉輪。</p>
<p>照著它的指示步驟一路做下去</p>
<p><span style="color: #ff0000;">8.4網格劃分</span><br/> 網格選項離散化的模型成小的元件</p>
<p><span style="color: #ff0000;">8.5荷載</span><br/> 施加在實體模型上的負載應是輸入到系統中。用於葉輪，假設主要力作用於渦輪機葉片的凹表面上。這種加載可以通過所有五個表面上正常的壓力近似。由於我們不關心負荷的大小，讓我們的價值為100磅/平方英寸英寸誇大葉片的變形。</p>
<p><span style="color: #ff0000;">8.6邊界條件</span><br/> 葉輪繞圓錐體的軸與軸的軸旋轉，如您在前幾章的裝配中所看到的那樣。它不是固定的，但我們關心的是葉片相對於葉輪芯的變形。錐形芯相對固定，葉片的變形要進行相應的分析。</p>
<p><span style="color: #ff0000;">8.7結果與模擬</span><br/> 8.7.1解決了模擬<br/> 的有限元模型，現在可以解決和分析。這是一個很好的做法，為模型完成第一次檢查之前，我們進入模型求解。要檢查模型</p>
<p><span style="color: #ff0000;">8.7.2 FEA結果</span></p>
<p>可以輕鬆地解釋從顏色編碼的結果。橘紅色顯示的最大變形區和藍色區域顯示的最小變形區。可以觀察到，由於錐形核心是固定的，它經歷零變形。</p>
<p>8.7.3仿真和動畫<br/> 點擊頂部帶狀條結果選項卡上。一種用於動畫組上可以看到其如下</p>
<p>可以看到負載應用到葉片葉輪變形的動畫。</p>
<p><span style="color: #ff0000;">8.8練習</span></p>
<p><span style="color: #ff0000;">8.8.1手扳壓機欄</span><br/> 打開文件“Arborpress_L-bar.prt'，做一個類似的結構分析，考慮材料如鋼。用於網格的元件的尺寸和類型應為'10'和'四（10）'。對於負載，與應用500的頂表面上的大小的常壓如示於下面的第一個圖。</p>
<p><span style="color: #ff0000;">8.8.2 搖臂</span><br/> 在本練習中，您將檢查元素類型和網格大小對有限元分析結果的影響。打開第 4 章中建模的搖臂。分配以下材料屬性：Young 的模量 = 3.0 × 107 psi，泊森的比率 = 0.29，品質密度 = 7.35 × 10-4 slug/in3。修復計數器孔孔和計數器沉孔（即修復圓柱面），如下圖所示，並施加 600 psi 值的壓力負載，以正常顯示的面。對於以下四種情況中，分別獲取偏轉輪廓和 Von-Mises 應力輪廓。</p>
<p>week13</p>
<p>webots tutorial </p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/lZAOZRYMrr4" width="560"></iframe></p>
<p>week10~12 進度報告</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/BCSsnO3t-4I" width="560"></iframe></p>
<p>week14   </p>
<p>tutorial 2 and 3</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/0G8syhuB-h0" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/QIqU_SZu_vo" width="560"></iframe></p>
<p></p><h3>proe的開發緣起</h3>
<p><img alt="" height="121" src="/images/pro-e.jpg" width="409"/></p>
<p>pro-e是Pro/Engineer的簡稱，更常用的簡稱是ProE或Pro/E，Pro/E是美國參數技術公司（Parametric Technology Corporation，簡稱PTC）的重要產品，在目前的三維造型軟件領域中佔有著重要地位。</p>
<p>pro-e作為當今世界機械CAD/CAE/CAM領域的新標準而得到業界的認可和推廣，是現今主流的模具和產品設計三維CAD/CAM軟件之一。</p>
<p><span>Pro/ENGINEER在2010年8月改名為「<b>Creo Elements/Pro</b>」</span></p>
<p><span><span>2011年6月再改名為「</span><b>Creo Parametric</b><span>」</span></span></p><h2>Week15~Week18</h2>
<p>week15  進度回報</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Ax4Wkw_jcnU" width="560"></iframe></p>
<p>week16 越野車組裝並轉檔</p>
<p>主體及輪胎輪軸</p>
<p><img alt="" height="282" src="/images/solvespace_bo3GDP5wsD.png" width="502"/></p>
<p><img alt="" height="285" src="/images/solvespace_WJPm6mGVyi.png" width="507"/></p>
<p><img alt="" height="295" src="/images/solvespace_yRW6gbyjGF.png" width="525"/></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/rwK6VrkKXkU" width="560"></iframe></p>
<p>week17 越野車模擬</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/V7ApAskcuag" width="560"></iframe></p>
<p>week18 期末報告</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/BddMES5-qH4" width="560"></iframe></p><h3>Building a clean model tutorial 翻譯</h3>
<p>Model definition</p>
<p>Now we are ready to define our model. We start by building the model herarchy: we attach the last dynamic robot link (<em>robot_link_dyn6</em>) to its corresponding joint (<em>robot_joint6</em>) by selecting <em>robot_link_dyn6</em>, then control-selecting <em>robot_joint6</em>, then [Menu bar --&gt; Edit --&gt; Make last selected object parent]. We could also have done this step by simply dragging object <em>robot_link_dyn6</em> onto <em>robot_link6</em> in the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">scene hierarchy</a></span>. We go on by now attaching <em>robot_joint6</em> to <em>robot_link_dyn5</em>, and so on, until arrived at the base of the robot. We now have following scene hierarchy:</p>
<p>型號定義</p>
<p>現在我們準備定義模型了。我們從建立模型層次結構開始：通過選擇<em>robot_link_dyn6</em>，然後控制選擇<em>robot_joint6</em>，然後選擇<span>[</span>菜單欄<span>-&gt;</span>編輯<span>-&gt;</span>使最後一個選中的對象，將最後一個動態機器人鏈接（<em>robot_link_dyn6</em>）附加到其相應的關節（<em>robot_joint6</em>）。<span>]</span>。我們也可以做這一步通過簡單的拖動對象<em>robot_link_dyn6</em>到<em>robot_link6</em>在<span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy"><span>場景層次</span></a></span>。現在，我們將<em>robot_joint6</em>附加到<em>robot_link_dyn5</em><em>上</em>，依此類推，直到到達機器人的底部。現在，我們具有以下場景層次結構：</p>
<p> So we rename <em>robot</em> to <em>robot_visibleBase</em>, and <em>robot_dyn</em> to <em>robot</em>. Now we select the base of the hierarchy tree (i.e. object <em>robot</em>) and in the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">object common properties</a></span> we enable <strong>Object is model base</strong>. We also enable <strong>Object/model can transfer or accept DNA</strong>. A model bounding box appeared, encompassing the whole robot. The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints. We now exclude the joints from the model bounding box by enabling the <strong>Don't show as inside model selection</strong> item for all joints. We could do the same procedure for all invisible items in our model. This is also a useful option in order to also exclude large sensors or other items from the model bounding box. We now have following situation:</p>
<p>我們將<em>robot</em>重命名為<em>robot_visibleBase</em>，並將<em>robot_dyn</em>重命名為<em>robot</em>。現在，我們選擇層次結構樹的基礎（即對像<em>機械手</em>），並在<span><a href="http://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm"><span>對象公共屬性中</span></a></span>啟用<span>“ </span><strong>對象為模型基礎<span>”</span></strong>。我們還使<strong>對象<span>/</span>模型可以轉移或接受<span>DNA</span></strong>。出現了一個模型包圍盒，包圍了整個機器人。但是，邊界框似乎太大：這是因為邊界框還包含不可見的項，例如關節。現在，通過對所有關節啟用<strong>“</strong><strong>不顯示為內部模型<span>”</span>選擇</strong>項，將關節從模型邊界框中排除。我們可以對模型中的所有不可見項執行相同的過程。這也是一個有用的選項，可以將大型傳感器或其他項目也排除在模型邊界框之外。我們現在有以下情況：</p>
<p> We now protect our model from accidental modification. We select all visible objects in the robot, then enable <strong>Select base of model instead</strong>: if we now click a visible link in the scene, the base of the robot will be selected instead. This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy. We now put the robot into a correct default position/orientation. First, we save current scene as a reference. Then we select the model and <span><a href="http://www.coppeliarobotics.com/helpFiles/en/coordinateDialog.htm">modify its position/orientation</a></span> appropriately. It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0.</p>
<p>現在，我們保護模型免受意外修改。我們選擇機器人中所有可見的對象，然後啟用<span>“ </span><strong>選擇模型的基礎<span>”</span></strong>：如果現在單擊場景中的可見鏈接，則會改為選擇機器人的基礎。這使我們可以像對待單個對像一樣操作模型。我們仍然可以通過按住<span>Shift</span>鍵並單擊場景或在場景層次中選擇對象來選擇機器人中的可見對象。現在，我們將機器人置於正確的默認位置<span>/</span>方向。首先，我們將當前場景保存為參考。然後我們選擇模型並<span><a href="http://www.coppeliarobotics.com/helpFiles/en/coordinateDialog.htm"><span>修改其位置/</span><span>方向</span></a></span>適當地。將模型（即其基礎對象）放置在<span>X = 0</span>和<span>Y = 0</span>處被認為是一種好習慣。</p>
<p> We now run the simulation: the robot will collapse, since the joints are not controlled by default. <span><a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm#joints">When we added the joints in the previous stage</a></span>, we created joints in force/torque mode, but their motor or controller was disabled (by default). We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them. In the joint dynamic properties, we click <strong>Motor enabled</strong> and adjust the <strong>maximum torque</strong>. We then click <strong>Control loop enabled</strong> and select <strong>Position control (PID)</strong>. We now run the simulation again: the robot should hold its position. Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines. You can do this via the appropriate <span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars">toolbar button</a></span>, or in the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/dynamicsDialog.htm">general dynamics properties</a></span>.</p>
<p>現在我們運行模擬：由於默認情況下關節不受控制，因此機器人將崩潰。<span><a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm#joints"><span>在上一階段添加關節時</span></a></span>，我們以力<span>/</span>扭矩模式創建了關節，但其電動機或控制器已禁用（默認情況下）。現在，我們可以根據需要調整關節。在我們的案例中，我們希望為每個控制器都提供一個簡單的<span>PID</span>控制器。在關節動態屬性中，單擊<span>“ </span><strong>啟用電動機<span>”</span></strong>並調整<strong>最大扭矩</strong>。然後，我們點擊<span>“ </span><strong>啟用控制環<span>”</span>，</strong>然後選擇<span>“ </span><strong>位置控制（<span>PID</span>）<span>”</span></strong>。現在，我們再次運行仿真：機器人應保持其位置。嘗試切換當前的物理引擎，以查看行為在所有受支持的物理引擎之間是否一致。您可以通過適當的<span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars"><span>工具欄按鈕</span></a></span>，或在<span><a href="http://www.coppeliarobotics.com/helpFiles/en/dynamicsDialog.htm"><span>常規動力學屬性中執行此操作</span></a></span>。</p>
<p> During simulation, we now verify the scene dynamic content via the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars">Dynamic content visualization &amp; verification toolbar button</a></span>. Now, only items that are taken into account by the physics engine will be display, and the display is <span><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#dynamicContentVisualization">color-coded</a></span>. It is <strong>very important</strong> to always do this, and specially when your dynamic model doesn't behave as expected, in order to quickly debug the model. Similarly, always look at the scene hierarchy during simulation: dynamically enabled objects should display a ball-bounding icon on the right-hand side of their name.</p>
<p>在仿真過程中，我們現在通過<span>“ </span><span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars"><span>動態內容可視化和驗證”</span><span>工具欄按鈕來</span></a></span>驗證場景動態內容。現在，將僅顯示物理引擎考慮的項目，並且該顯示使用<span><a href="http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#dynamicContentVisualization"><span>顏色編碼</span></a></span>。這是<strong>非常重要的</strong>，始終做到這一點，特別是當預期，為了快速調試模型動態模型不表現。同樣，在仿真過程中請始終查看場景層次：動態啟用的對象應在其名稱的右側顯示一個球形圖標。</p>
<p>Finally, we need to prepare the robot so that we can easily attach a gripper to it, or easily attach the robot to a mobile platform (for instance). Two dynamically enabled shapes can be rigidly attached to each other in two different ways:</p>
<p>  <strong>by grouping them</strong>: select the shapes, then [Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Group selected shapes].</p>
<p>  <strong>by attaching them via a force/torque sensor</strong>: a <span><a href="http://www.coppeliarobotics.com/helpFiles/en/forceSensors.htm">force torque sensor</a></span> can also act as a rigid link between two separate dynamically enabled shapes.</p>
<p>In our case, only option 2 is of interest. We create a force/torque sensor with [Menu bar --&gt; Add --&gt; Force sensor], then move it to the tip of the robot, then attach it to object <em>robot_link_dyn6</em>. We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available). We also change its name to <em>robot_attachment</em>:</p>
<p>最後，我們需要準備機器人，以便我們可以輕鬆地將抓取器連接到它，或輕鬆地將機器人連接到移動平台（例如）。可以通過兩種不同的方式將兩個動態啟用的形狀嚴格地彼此附加：</p>
<p>  <strong>通過對它們進行分組</strong>：選擇形狀，然後單擊<span>[</span>菜單欄<span>-&gt;</span>編輯<span>-&gt;</span>分組<span>/</span>合併<span>-&gt;</span>對選定形狀進行分組<span>]</span>。</p>
<p>  <strong>通過通過力<span>/</span>扭矩傳感器進行連接</strong>：<span><a href="http://www.coppeliarobotics.com/helpFiles/en/forceSensors.htm"><span>力扭矩傳感器</span></a></span>還可以充當兩個單獨的動態啟用形狀之間的剛性鏈接。</p>
<p>在我們的情況下，只有選項<span>2</span>是有意義的。我們使用<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt;</span>力傳感器<span>]</span>創建一個力<span>/</span>扭矩傳感器，然後將其移動到機器人的尖端，然後將其附加到對象<em><span>robot_link_dyn6</span>上</em>。我們會適當地更改其尺寸和外觀（紅色力<span>/</span>扭矩傳感器通常被視為可選的連接點，請檢查可用的各種機器人型號）。我們還將其名稱更改為<em><span>robot_attachment</span></em>：</p>
<p> Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars">Assembling/disassembling toolbar button</a></span>. The gripper goes into place:</p>
<p>現在，我們將抓取器模型拖到場景中，使其保持選中狀態，然後按住<span>Control</span>鍵並點按附件力傳感器，然後單擊<span>“ </span><span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars"><span>裝配/</span><span>拆卸”</span><span>工具欄按鈕</span></a></span>。夾持器到位：</p>
<p>The gripper knew how to attach itself because it was appropriately configured during its model definition. We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. We select the robot model, then click <strong>Assembling</strong> in the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">object common properties</a></span>. Set an empty string for <strong>'Parent' match values</strong>, then click <strong>Set matrix</strong>. This will memorize the current base object's local transformation matrix, and use it to position/orient itself relative to the mobile robot's attachment point. To verify that we did things right, we drag the model <em>Models/robots/mobile/KUKA Omnirob.ttm</em> into the scene. Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars">Assembling/disassembling toolbar button</a></span>. Our robot should correctly place itself on top of the mobile robot:</p>
<p>抓具知道如何附加自身，因為它在模型定義期間進行了適當的配置。現在，我們還需要正確配置機器人模型，以便它將知道如何將自己附加到移動基座上。我們選擇機器人模型，然後在<span><a href="http://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm"><span>對象公共屬性中</span></a></span>單擊<span>“ </span><strong>組裝</strong><span> ” </span>。為<strong>“</strong><strong>父項<span>”</span>匹配值</strong>設置一個空字符串，然後點擊<strong>設置矩陣</strong>。這將記住當前基礎對象的局部轉換矩陣，並使用它相對於移動機器人的附著點定位<span>/</span>定向。為了驗證我們做的正確，我們拖動模型<em>Models / robots / mobile / KUKA Omnirob.ttm</em>進入現場。然後，選擇機器人模型，然後在移動平台上按住<span>Control</span>鍵並單擊其中一個附接點，然後單擊<span>“ </span><span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#toolbars"><span>組裝/</span><span>拆卸”</span><span>工具欄按鈕</span></a></span>。我們的機器人應該正確地將自己放置在移動機器人的頂部：</p>
<p>Now we could add additional items to our robot, such as sensors for instance. At some point we might also want to attach <span><a href="http://www.coppeliarobotics.com/helpFiles/en/scripts.htm">embedded scripts</a></span> to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand <span><a href="http://www.coppeliarobotics.com/helpFiles/en/accessingGeneralObjects.htm">how object handles are accessed from embedded scripts</a></span>. We can also control/access/interface our model from a <span><a href="http://www.coppeliarobotics.com/helpFiles/en/plugins.htm">plugin</a></span>, from a <span><a href="http://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a></span> client, from a <span><a href="http://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm">ROS</a></span> node, from a <a href="http://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm">BlueZero</a> node, or from an <span><a href="http://www.coppeliarobotics.com/helpFiles/en/addOns.htm">add-on</a></span>.</p>
<p>Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --&gt; File --&gt; Save model as...]. If we saved it in the <em>model</em> folder, then the model will be available in the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#ModelBrowser">model brower</a></span>.</p>
<p>現在，我們可以向機器人添加其他項目，例如傳感器。在某些時候，我們可能還希望將<span><a href="http://www.coppeliarobotics.com/helpFiles/en/scripts.htm"><span>嵌入式腳本</span></a></span>附加到我們的模型中，以便控制其行為或出於各種目的對其進行配置。在這種情況下，請確保了解<span><a href="http://www.coppeliarobotics.com/helpFiles/en/accessingGeneralObjects.htm"><span>如何從嵌入式腳本訪問對象句柄</span></a></span>。我們還可以通過<span><a href="http://www.coppeliarobotics.com/helpFiles/en/plugins.htm"><span>插件</span></a></span>，<span><a href="http://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm"><span>遠程API</span></a></span>客戶端，<span><a href="http://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm">ROS</a></span>節點，<span><a href="http://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm">BlueZero</a></span>節點或<span><a href="http://www.coppeliarobotics.com/helpFiles/en/addOns.htm"><span>附加組件</span></a></span>來控制<span>/</span>訪問<span>/</span>接口模型。</p>
<p>現在，確保已恢復在機械手和抓爪安裝過程中所做的更改，我們折疊了機械手模型的層次樹，選擇了模型的基礎，然後使用<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>將模型另存為<span>...]</span>。如果我們將其保存在<em>模型</em>文件夾中，則該模型將在<span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#ModelBrowser"><span>模型瀏覽器中</span></a></span>可用。</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p><h1>Note</h1>
<h2>solvespace 常用指令</h2>
<p>shift+W 建立平面</p>
<p>P 點</p>
<p>C 圓</p>
<p>A 曲線</p>
<p>S 線</p>
<p>D 標註</p>
<p>N 角度標註</p>
<p>M 鎖定中心</p>
<p>V 鉛直</p>
<p>H 水平</p>
<p>Q 兩線相同</p>
<p>O 重和</p>
<p>G 建構線</p>
<p></p>
<p><span></span></p>